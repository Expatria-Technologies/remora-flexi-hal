
# load the realtime components

	loadrt [KINS]KINEMATICS
	loadrt [EMCMOT]EMCMOT base_period_nsec=[EMCMOT]BASE_PERIOD servo_period_nsec=[EMCMOT]SERVO_PERIOD num_joints=[KINS]JOINTS

	loadrt flexi chip_type=STM SPI_clk_div=32 PRU_base_freq=120000
	loadrt not names=stepen_not,stepen_z_not,probe_basic_time_not
	loadrt time names=probe_basic_time_time
	loadrt estop_latch names=estop_latch
	#loadusr -W vfdmod --debug vfdmod.ini
	#loadusr -W vfdmod vfdmod.ini


# probe_basic time
	addf probe_basic_time_time servo-thread
	addf probe_basic_time_not servo-thread

# add the remora and motion functions to threads

	addf flexi.read servo-thread
	addf motion-command-handler servo-thread
	addf motion-controller servo-thread
	addf flexi.update-freq servo-thread
	addf flexi.write servo-thread
	addf stepen_not servo-thread
	addf stepen_z_not servo-thread
	addf estop_latch servo-thread

# vfdmod
	#net spindle-speed-cmd => vfdmod.spindle.rpm-in <= spindle.0.speed-out
	#net spindle-speed-fb => vfdmod.spindle.rpm-out <= spindle.0.speed-in
	#net spindle-at-speed <= vfdmod.spindle.at-speed <= spindle.0.at-speed
	#net spindle-forward => vfdmod.control.run-forward <= spindle.0.forward
	#net spindle-reverse => vfdmod.control.run-reverse <= spindle.0.reverse


# estop loopback, SPI comms enable and feedback
	net user-enable-out <= iocontrol.0.user-enable-out => flexi.SPI-enable
	net user-request-enable <= iocontrol.0.user-request-enable => flexi.SPI-reset estop_latch.reset
	#estop_latch returns 'ok' when fault-in is false, ok-in is true, and reset changes from false to true. 
	net estop-fault_in <= flexi.input.HALT => estop_latch.fault-in
	net remora-status <= flexi.SPI-status => estop_latch.ok-in
	net estop-status <= estop_latch.ok-out => iocontrol.0.emc-enable-in


# Joint 0 setup

	setp flexi.joint.0.scale [JOINT_0]SCALE
	setp flexi.joint.0.maxaccel [JOINT_0]STEPGEN_MAXACCEL
	setp flexi.joint.0.pgain [JOINT_0]P_GAIN

	net xpos-cmd <= joint.0.motor-pos-cmd => flexi.joint.0.pos-cmd  
	net j0pos-fb <= flexi.joint.0.pos-fb => joint.0.motor-pos-fb
	net j0enable <= joint.0.amp-enable-out => flexi.joint.0.enable

	net x-home <= joint.0.home-sw-in => flexi.input.X_LIMIT


# Joint 1 setup

	setp flexi.joint.1.scale [JOINT_1]SCALE
	setp flexi.joint.1.maxaccel [JOINT_1]STEPGEN_MAXACCEL
	setp flexi.joint.1.pgain [JOINT_1]P_GAIN

	net j1pos-cmd <= joint.1.motor-pos-cmd => flexi.joint.1.pos-cmd
	net j1pos-fb <= flexi.joint.1.pos-fb => joint.1.motor-pos-fb 
	net j1enable <= joint.1.amp-enable-out => flexi.joint.1.enable

	net y-home <= joint.1.home-sw-in => flexi.input.Y_LIMIT


# Joint 2 setup

	setp flexi.joint.2.scale [JOINT_2]SCALE
	setp flexi.joint.2.maxaccel [JOINT_2]STEPGEN_MAXACCEL
	setp flexi.joint.2.pgain [JOINT_2]P_GAIN

	net j2pos-cmd <= joint.2.motor-pos-cmd => flexi.joint.2.pos-cmd
	net j2pos-fb <= flexi.joint.2.pos-fb => joint.2.motor-pos-fb
	net j2enable <= joint.2.amp-enable-out => flexi.joint.2.enable

	net z-home <= joint.2.home-sw-in => flexi.input.Z_LIMIT


# Joint 3 setup

	setp flexi.joint.3.scale [JOINT_3]SCALE
	setp flexi.joint.3.maxaccel [JOINT_3]STEPGEN_MAXACCEL
	setp flexi.joint.3.pgain [JOINT_3]P_GAIN

	net j3pos-cmd <= joint.3.motor-pos-cmd => flexi.joint.3.pos-cmd
	net j3pos-fb <= flexi.joint.3.pos-fb => joint.3.motor-pos-fb
	net j3enable <= joint.3.amp-enable-out => flexi.joint.3.enable

	net A-home <= joint.3.home-sw-in => flexi.input.A_LIMIT


# Joint 4 setup

	setp flexi.joint.4.scale [JOINT_4]SCALE
	setp flexi.joint.4.maxaccel [JOINT_4]STEPGEN_MAXACCEL
    setp flexi.joint.4.pgain [JOINT_4]P_GAIN
    
	net j4pos-cmd <= joint.4.motor-pos-cmd => flexi.joint.4.pos-cmd
	net j4pos-fb <= flexi.joint.4.pos-fb => joint.4.motor-pos-fb
	net j4enable <= joint.4.amp-enable-out => flexi.joint.4.enable

	net b-home <= joint.4.home-sw-in => flexi.input.B_LIMIT

# Motor enables

	#inverted 
	net j0enable => stepen_not.in
	net stepen_inv => stepen_not.out <= flexi.output.STEP_EN
	net j2enable => stepen_z_not.in
	net stepen_z_inv => stepen_z_not.out <= flexi.output.STEP_EN_Z

	#non-inverted
	#net j0enable => flexi.output.STEP_EN
	#net j2enable => flexi.output.STEP_EN_Z



# User Buttons

#Halt is shared with motor alarms and is up in the estop loop.
#net hold-button <= halui.program.pause => flexi.input.HOLD #will likely need a toggle. See jog2k.
#net start-button <= halui.program.run <= flexi.input.CYC_START # add toggle to single step when in hold

